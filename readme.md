# SWiG parameter management proposal demonstration

## Schema
* `parameters_schema.json` Defines the structure of the parameter standard
* `parameters.json` demonstrates a cut-down example of a few parameters used in the demonstration code or with particular features of interest
* `parameters.proto` is the proposed protobuf definition to send parameter messages using the standard. It is generated by running the simple script `python\json_to_proto.py` from this level
* `python\` folder contains demonstration code to show a very simple implementation of the standard (see notes in demonstration section below)

## Demo
The demonstration code simulates a simple configuration of a vessel(`vessel.py`) with a cabled connection to a wireless modem mounted on an ROV(`rov.py`). The modem on the ROV communicates wirelessly to/from a remote device (`remote.py`)

To simplify the code, common functionality shared between all simulated nodes has been extracted to `common.py`, which is imported to each of the node's Python files.

Communication on each simulated link is simulated by a UDP port or serial connection. For UDP, each simulated device port (vessel, ROV (wet and dry sides) and remote device wet side) each listen on one UDP port on the IP address defined in `common.py`. Vessel only communicates with ROV dry side, and remote only communicates with ROV wet side, no messages are sent directly between the vessel and the remote unit.

The protobuf definition includes source and target identifiers, then any or all of the following
* A list of parameter id's which are requested from the target
* A set of responses which are parameter values reported by the target (typically as a response to the above request)
* A set of parameters and values which are sent to the target to update its configuration

The demo scripts read the json file directly to get detail which can be used to process and present the data (data types, meanings etc). "Magic numbers" read manually from the JSON and added to the code are kept to a minimum. It should be possible to reference each parameter by id (number) or name (machine-readable name field), but that isn't fully used in the demo.

### Usage
Use Python to run the rov.py and remote.py scripts, starting the simulated subsea devices.
Then either:
* use Python to run vessel.py or
* use Python to run mqtt_bridge.py and then in a separate terminal use Python to run mqtt_vessel.py

Either vessel or MQTT vessel demos will interrogate each modem (the ROV one and the remote one) for some parameters and print the results on the console.

If running the MQTT version, an MQTT client such as [MQTT explorer](https://mqtt-explorer.com/) connected to the same broker is useful to view the updated broker state

## Serial support
To use serial ports for communications, install python serial
`pip install pyserial` installs python serial port support
And change the definitions for each end of the required connection (ports, speeds) in `common.py`
Example implementation of serial and UDP alternatives are commented out in the supplied `common.py`

## Protobuf
`pip install protobuf` installs protobuf support for python
`pip install cobs` installs COBS support, to guarantee buffers only have nulls as terminating bytes for transmission
`pip install paho-mqtt` installs MQTT support for the MQTT bridge demonstration
`pip show protobuf` confirms version of python protobuf installed 

On initial test, output of pip show protobuf was
```
Name: protobuf
Version: 4.21.6
```

Install a matching version of protoc (e.g. from [protobuf release page](https://github.com/protocolbuffers/protobuf/releases) ).

For example, to match the python version installed above, [V21.6-win64](https://github.com/protocolbuffers/protobuf/releases/download/v21.6/protoc-21.6-win64.zip) was used.

Command line to create `python\parameters_pb2.py` (assuming protoc is extracted to a folder called `protoc-21.6` 'beside' the one containing this README file) :
```
..\protoc-21.6\bin\protoc.exe --python_out=python .\parameters.proto
```

## Nanopb
Nanopb is an implementation of protobuf to generate C code that is suitable for embedded use. 
To create the C library, do the following:

- `git clone https://github.com/nanopb/nanopb.git)`
- `python3 nanopb/generator/nanopb_generator.py --output-dir=C parameters.proto`
This will create the files `parameters.pb.h` and `parameters.pb.c` in the ./C/ directory.


## Resources
- Use [The JSON Faker](https://json-schema-faker.js.org/) to generate fake JSON for the given schema to check schema constraints- paste the proposed schema in to the left window, and each time you press 'Generate' on the top right a fake file will be produced in the right window which complies with the schema
- Use [The JSON Validator](https://www.jsonschemavalidator.net/) to validate the standard specification data against the given schema. Note that only the outer array of the specification file is required, remove the preceding `{"all":` and trailing `}` text (some validators need them, some don't accept them... there's probably a reason for that which can be fixed, somehow)
- Tutorialspoint provide a [useful protobuf tutorial](https://www.tutorialspoint.com/protobuf/index.htm)

## Misc Notes
- Index by parameter ID, easy to make it unique
- default for all access is 'no', only list free/authenticated. If manufacturer optional, add separate field for this?
- Minimum for Standard compliance major and minor should always be set as the current version of the standard as of this document
- Wet type 0=acoustic, 1=optical, 2=inductive, 3=radio, minimum and maximum set accordingly. Does it need to be a list of types supported in this standard instead?
- Background light level and noise are set as read-only (writable with auth on spreadsheet V3_20Jul22 presumed typo)
- `access` properties:
    - `read` and `write` – This parameter is readable (for `read`) or writeable (for `write`) for this interface if implemented (see `read_option` / `write_option`). If not specified, default to false, i.e. this parameter is not accessible to be read (`read`) or written (`write`) on this interface
    - `read_option` and `write_option` – Implementation of this parameter is optional. If not specified, default to false, i.e. the parameter must be implemented. Some examples where this might be useful:
        - parameters which are useful to report or characterise a link but may restrict implementation for simple systems and is not required to establish and maintain a wireless link (e.g. performance stats)
        - parameters which may be widely implemented but are not essential to establish and maintain the wireless link, but if implemented would be desirable to have a consistent interface (e.g. reading ambient temperature)
        - parameters which are only relevant where additional functionality is included (e.g. a ‘sleep to low power after X minutes’ configuration would require a consistent interface, but is not required for communications)
   - `read_auth` and `write_auth` – This parameter may only be read (`read_auth`) or written (`write_auth`) by an authenticated connection. If not specified, default to false, i.e. the parameter is not protected by SWiG specified authentication. Note:
       - SWiG does not yet specify how to implement an authenticated connection, and does not guarantee to ever implement such a connection, so the associated `_auth` effectively makes the parameter unavailable until authentication is implemented.
       - Specification of an authenticated connection is complex. For example, SWiG will need to decide how authentication is implemented (TLS, tokens, or one of many other options), whether per connection (i.e. make and authenticate connection) or per message (where each message would need authentication tokens to be included), and many other items.
       - Specification will also needs to clarify if `_auth` properties mean that authentication is a)allowed or b)required?


